---
title: 初识高精度计算
date: 2025-10-18 19:27:44
tags: [入门, C语言]
categories: [技术探索]
---
**时间经过**：2025.10.10-2025.10.15
***
那是平平无奇的一天，我打开了洛谷，看见了一道题，要求进行阶乘的累加。
<!-- more -->
题目上赫然写着“高精度”，但我并不知道这是什么意思。于是我忽略了这三个字。

我心想，这也太简单了啊，秒了。

一顿操作猛如虎，一半AC一半WA。
<a href="一顿操作猛如虎.jpg" data-fancybox="gallery" data-caption="一顿操作猛如虎">
  <img src="一顿操作猛如虎.jpg" width="100%" alt="一顿操作猛如虎">
</a>

上网搜索“高精度计算”，就好像打开了一道新的大门。
接下来的几天，我一有空就在研究这个，加法，乘法，洛谷OJ通过了之后又研究减法，除法。一直到放弃。
在这过程中，我基本上是一边查一边写，一边问AI一边写
确实又对函数和数组熟悉了不少

不多说了，看看代码。
<details>
<summary>点击查看我都写了什么东西</summary>

```c
//高精度计算
//仅支持正整数

//存在的问题
//1.输入的数字还是int，不能支持很大的数字
//改进思路：或许可以直接用循环输入数组
//2.各个函数对于边界的处理，我并不确定是否正确，比如i<LEN还是i<LEN-1还是i<LEN-2
//改进思路：以后再看
//3.sub函数和div函数内部，有可能会互换num1和num2，这就破坏了输入的数据
//改进思路：使用临时变量，比如temp_num1, temp_num2
//4.变量名不够清晰，太多temp temp_等诸如此类含糊不清的名字，不便于维护
//改进思路：以后逐渐养成习惯再说
//5.太习惯用//就不会用/**/了
//改进思路：下次一定
//6.不行了，除法还是有问题。我放弃了。。以后再说吧。我尽力了。
//7.不行，我又来了。继续战斗。
//8.不行了。写的太长了，AI已经说不清楚了。我决定放弃。日后再战。
//9.诶，我要是先写高精度除以低精度，再写高精度除以高精度呢，或许能逻辑更清晰一些（


#include <stdio.h>
#include <string.h>

int cmp(int num1[], int num2[], int LEN);
void add(int num1[], int num2[], int result[], int LEN);
int sub(int num1[], int num2[], int result[], int LEN);
void mul(int num1[], int num2[], int result[], int LEN);
void div(int num1[], int num2[], int result[], int remainder[], int LEN);


//main函数是输入数字ab，输出加减乘除
int main(void)
{
	//输入
	int a, b;
	scanf("%d %d", &a, &b);
	
	//数字a, b转换成数组num1[], num2[]
	//目前写的是最大1000位
	int num1[1000] = {0};
	int num2[1000] = {0};
	int i = 0, j = 0;
	while(a > 0)
	{
		num1[i] = a % 10;
		a /= 10;
		i++;
	}
	while(b > 0)
	{
		num2[j] = b % 10;
		b /= 10;
		j++;
	}
	
	//结果初始化
	int result1[1000] = {0};
	int result2[1000] = {0};
	int result3[1000] = {0};
	int result4[1000] = {0};
	int remainder[1000] = {0};     //余数，仅除法用
	
	
	
	//运算
	//想用哪个，就取消哪个的注释，就好了
	//add(num1, num2, result1, 1000);
	//int judge = sub(num1, num2, result2, 1000);
	//mul(num1, num2, result3, 1000);
	div(num1, num2, result4, remainder, 1000);
	
	
	
	
	//计算结果总位数len
	//记得改result几
	int len;
	for(len = 999; len>=0; len--)
	{
		if(result4[len] != 0)
		{
			break;
		}
	}
	len++;
	
	
	
	
	//输出结果
	//记得改result几
	
	
	
	
	//以下仅加法乘法适用
	/*
	for(int j = len-1; j>=0; j--)
	{
		printf("%d", result4[j]);
	}
	*/
	
	
	
	
	//以下仅除法适用
	//len_是余数remainder总位数
	int len_;
	for(len_ = 999; len_>=0; len_--)
	{
		if(result4[len_] != 0)
		{
			break;
		}
	}
	len_++;
	
	for(int j = len-1; j>=0; j--)
	{
		printf("%d", result4[j]);
	}
	
	printf("\n");
	
	for(int j = len_-1; j>=0; j--)
	{
		printf("%d", remainder[j]);
	}
	
	
	
	
	
	//以下仅减法适用
	/*
	switch(judge)
	{
		case 0:
			printf("0");
			break;
		case -1:
			printf("-");
		case 1:
			for(int j = len-1; j>=0; j--)
			{
				printf("%d", result2[j]);
			}
	}
	*/


	return 0;
}


//比较num1[LEN]和num2[LEN]大小
//仅限于这里高精度比大小，因为是逆序排列的
//num1 = num2返回0
//num1 > num2返回1
//num1 < num2返回-1
int cmp(int num1[], int num2[], int LEN)
{
	//i是num1最高位索引
	int i = LEN-1;                    //LEN位的num1，最大的索引是num1[LEN-1]
	for(; i >= 0; i--)
	{
		if(num1[i] != 0)
		{
			break;
		}
	}
	//j是num2最高位索引
	int j = LEN-1;                    //LEN位的num1，最大的索引是num1[LEN-1]
	for(; j >= 0; j--)
	{
		if(num2[j] != 0)
		{
			break;
		}
	}
	//max是i和j较大者，也就是需要比较大小的最高位
	int max = (i > j ? i : j);
	
	//我觉得no是序号的意思
	for(int no = max; no >= 0; no--)
	{
		if(num1[no] > num2[no])
		{
			return 1;
		}
		else if(num1[no] < num2[no])
		{
			return -1;
		}
	}
	return 0;
}


//最多能处理LEN位数
//传入的num1和num2, [0]是个位数，[1]是十位数
//result是一个数组, [0]是个位数，[1]是十位数
void add(int num1[], int num2[], int result[], int LEN)
{
	//num1 + num2 = result
	
	for(int i = 0; i < LEN; i++)
	{
		result[i] = num1[i] + num2[i];
	}
	
	//处理进位
	for(int j = 0; j <= LEN-1; j++)            //后续涉及到result[j+1]，所以要j <= LEN-1，避免数组越界
	{		
		result[j+1] += result[j] / 10;
		result[j] %= 10; 	
	}
}


//最多能处理LEN位数，但结果result也要是少于LEN位数！！！
//若result为负数，则应少于LEN-1位数！！！
//传入的num1和num2, [0]是个位数，[1]是十位数
//result是一个数组, [0]是个位数，[1]是十位数
//result = 0则return 0
//result > 0则return 1
//result < 0则return -1
//本函数只传回绝对值结果result，请在函数外负责负号'-'的打印
int sub(int num1[], int num2[], int result[], int LEN)
{
	//result = |num1 - num2| 
	
	if(cmp(num1, num2, LEN) == 0)
	{
		memset(result, 0, LEN * sizeof(int));
		return 0;
	}
	
	int judge = 0;
	//检查是否num1 >= num2
	//如果num1 < num2则使num1和num2互换。judge记为1，一会输出负数
	if(cmp(num1, num2, LEN) < 0)
	{
		judge = 1;
		int temp[LEN] = {0};
		memcpy(temp, num1, LEN*sizeof(int));
		memcpy(num1, num2, LEN*sizeof(int));
		memcpy(num2, temp, LEN*sizeof(int)); 
	}
	
	//计算result的绝对值
	for(int i = 0; i <= (LEN-1-1); i++)         //result数组初始化只到了LEN，所以最多只能到result[LEN-1]
	{
		if(num1[i] >= num2[i])
		{
			result[i] = num1[i] - num2[i];
		}
		else
		{
			result[i] = num1[i] + 10 - num2[i];
			num1[i+1] -= 1;                     //这里涉及到了num1[i+1]，所以i+1 <= LEN-1即i <= LEN-2
		}
	}
	
	if(judge == 0)
	{
		return 1;
	}
	else
	{
		return -1;
	}
}


//最多能处理LEN位数，但结果result也要是少于LEN位数！！！
//传入的num1和num2，[0]是个位数，[1]是十位数
//result是一个数组，[0]是个位数，[1]是十位数
void mul(int num1[], int num2[], int result[], int LEN)
{
	//num1 * num2 = result
	
	for(int i = 0; i < LEN ;i++)
	{
		for(int j = 0; j < LEN; j++)
		{
			result[i + j] += num1[i] * num2[j];
		}
	}
	
	for(int j = 0; j < LEN-1; j++)
	{
		result[j+1] += result[j] / 10;
		result[j] %= 10;
	}
}


void div(int num1[], int num2[], int result[], int remainder[], int LEN)
{
	//num1 ÷ num2 = result ……remainder
	
	//num1 = num2则商1余0
	if(cmp(num1, num2, LEN)==0)
	{
		memset(result, 0, LEN * sizeof(int));
		result[0] = 1;                                     //这行能行吗
		memset(remainder, 0, LEN * sizeof(int));
		return;                                            //return能行吗
	}
	
	//num1 < num2则商0余num1
	if(cmp(num1, num2, LEN) < 0)
	{
		memset(result, 0, LEN * sizeof(int));
		memcpy(remainder, num1, LEN * sizeof(int));
		return;                                            //return能行吗
	}
	
	//num1 > num2则正常除
	//i是num1最高位索引，num1一共有i+1位
	//求i
	int i = LEN-1;                          //最多LEN位的num1，最大的索引是num1[LEN-1]
	for(; i >= 0; i--)
	{
		if(num1[i] != 0)
		{
			break;
		}
	}
	//j是num2最高位索引，num2一共有j+1位
	//求j
	int j = LEN-1;                          //LEN位的num1，最大的索引是num1[LEN-1]
	for(; j >= 0; j--)
	{
		if(num2[j] != 0)
		{
			break;
		}
	}
	
	//初始化curr，一会用curr进行试商
	int curr[LEN] = {0};
	for(int count = i-j; count < LEN; count++)                           //把count换为正在试商的相关部分
	{
		curr[count - (i - j)] = num1[count];
	}
	
	//计算商                                                               m * num2移位，num1 -= m * num2
	for(int k = i-j; k >= 0; k--)
	{
		int m = 0;
		for(; m <= 10; m++)                                        //试商m，从0到9
		{
			int m_[LEN] = {0};                                             //把m换成数组形式的m_
			m_[0] = m;
			
			int mul_[LEN] = {0};                             //如果mul_ = m_ * num2 > curr说明已经超了，正确商是m-1
			mul(m_, num2, mul_, LEN);
			
			if((cmp(mul_, curr, LEN) > 0) && (m != 0))
			{
				m -= 1;
				break;
			}
			else if((cmp(mul_, curr, LEN) > 0) && (m == 0))
			{
				break;
			}
		}
		result[k] = m;                                       //试商结束
		
		int m_[LEN] = {0};
		m_[0] = m;
		int mul_[LEN] = {0};
		mul(m_, num2, mul_, LEN);
		int temp[LEN] = {0};                                //curr = curr - num2 * m_ （temp = curr - mul_再curr=temp）       if(k!= 0)  再 * 10 + 下一位[k-1]
		sub(curr, mul_, temp, LEN);
		memcpy(curr, temp, LEN * sizeof(int));
		
		if(k != 0)
		{
			for(int no_name = LEN-k; no_name > 0; no_name--)        //给变量起名太难了。。。
			{
				curr[no_name] = curr[no_name-1];
			}
			curr[0] = num1[k-1];
		}
	}
	
	//计算余数                                               //remainder = num1 - num2 * result  //我靠，AI提示说，最后的curr就是余数
	/*
	int mul_[LEN] = {0};
	mul(num2, result, mul_, LEN);
	sub(num1, mul_, remainder, LEN);
	*/
	memcpy(remainder, curr, LEN * sizeof(int));
}


//这里什么也没有，你在找什么  :p
```
</details>