---
title: ä¸€äº›å°ä¸œè¥¿
date: 2025-12-17 09:12:35
tags: [ç´¯äº†ä¸æƒ³å†™æ ‡ç­¾äº†]
categories: [æŠ€æœ¯æ¢ç´¢]
---
è¿™é‡Œè®°å½•äº†æˆ‘åšè¿‡çš„ä¸€äº›å°ä¸œè¥¿ã€‚è¿˜è›®æœ‰æ„æ€çš„
<!-- more -->
***
2025.12.06-2025.12.07
## æ‰‹åŠ¿æ§åˆ¶3Dæ˜Ÿäº‘
ä¸€å¤©ï¼Œæˆ‘åŒå­¦åœ¨æŠ–éŸ³ä¸Šç»™æˆ‘åˆ†äº«äº†ä¸€ä¸ªè§†é¢‘ï¼š
ä¸€ä½ç½‘å‹ç”¨gemini 3ï¼Œå‡ ä¸‹å°±åšå‡ºäº†ä¸€ä¸ªå¾ˆæœ‰æ„æ€çš„demoï¼Œæ˜¯åˆ©ç”¨æ‘„åƒå¤´å®æ—¶æ‹æ‘„ï¼Œå¹¶è¯†åˆ«æ‰‹éƒ¨åŠ¨ä½œï¼Œå¯¹æ˜Ÿäº‘ç²’å­æ•ˆæœè¿›è¡Œæ“æ§
æˆ‘ä¸€å¼€å§‹æƒ³çš„æ˜¯ï¼šå•Šè¿™ï¼Œæˆ‘æ—¢æ²¡æœ‰æ¢¯å­ä¹Ÿæ²¡æœ‰é’±ï¼Œå’‹åšå•Šã€‚ç®—äº†ç®—äº†ã€‚

åæ¥æˆ‘çµæœºä¸€åŠ¨å†åŠ å¿ƒè¡€æ¥æ½®ï¼Œå†³å®šç”¨deepseekå¸®æˆ‘åšã€‚
åœ¨deepseekçš„å¸®åŠ©ä¸‹æˆ‘çŸ¥é“äº†ï¼Œåªéœ€è¦åœ¨ä¸€ä¸ªæ–‡ä»¶å¤¹ä¸­åšå¥½ `.html` `.css` `.js`ä¸‰ä¸ªæ–‡ä»¶ï¼Œå†åŒå‡»æ‰“å¼€ `.html`ï¼Œå°±å¥½äº†ï¼Œéå¸¸çš„ç®€å•ã€‚
äºæ˜¯æˆ‘å¼€å§‹ç–¯ç‹‚åœ°å’Œdeepseekå¯¹è¯ã€‚

æˆ‘çš„å¤©å‘ï¼ŒåŸæ¥å’ŒAIå¯¹è¯æ¥å¤åˆ¶ä»£ç ï¼ŒçœŸçš„ä¸æ˜¯ä¸€ä»¶å®¹æ˜“çš„äº‹æƒ…ã€‚å› ä¸ºAIå¾ˆå®¹æ˜“å°±æŠŠè¿™ä¸ªbugä¿®å®Œä¹‹åæŠŠå¦ä¸€ä¸ªbugå¿˜äº†ã€‚
æˆ‘å°è¯•äº†ä¸€èˆ¬åœ°æé—®ã€å¼€æ–°å¯¹è¯æé—®ã€å…ˆè®©ä»–å†™æç¤ºè¯å†æé—®...

ä¸ç®¡æ€ä¹ˆè¯´ï¼Œç»è¿‡ä¸€ä¸ªä¸‹åˆï¼Œæˆ‘ä¹Ÿæ˜¯å¼„å‡ºæ¥äº†ä¸€ä¸ªdemo
ä¸è¿‡ä¹Ÿå°±åªæœ‰ä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œæ‰€ä»¥åªèƒ½åœ¨æœ¬åœ°ç©ç©
æ˜¯è¿™ä¸ªæ ·å­çš„
<a href="æ˜Ÿäº‘.jpg" data-fancybox="gallery" data-caption="æ‰‹åŠ¿æ§åˆ¶3Dæ˜Ÿäº‘">
  <img src="æ˜Ÿäº‘.jpg" width="50%" alt="æ‰‹åŠ¿æ§åˆ¶3Dæ˜Ÿäº‘">
</a>
å¦å¤–æˆ‘æŠŠä»£ç ä¹Ÿè´´åœ¨è¿™é‡Œï¼ˆè™½ç„¶å…¨éƒ½æ˜¯deepseekå†™çš„
<details>
<summary>è¿™æ˜¯html</summary>
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿æ§åˆ¶3Dæ˜Ÿäº‘</title>
    <link rel="stylesheet" href="style.css">
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>
    <div class="app-container">
        <!-- å›ºå®šæ ‡é¢˜åŒºåŸŸ -->
        <header class="header">
            <h1>
                <span class="emoji">ğŸŒŒ</span>
                <span class="title-text">æ‰‹åŠ¿æ§åˆ¶3Dæ˜Ÿäº‘</span>
            </h1>
            <p class="subtitle">é€šè¿‡æ‘„åƒå¤´æ•æ‰æ‰‹éƒ¨åŠ¨ä½œï¼Œå®æ—¶æ§åˆ¶æ˜Ÿäº‘çš„å½¢æ€å˜åŒ–</p>
            
            <!-- é¡¶éƒ¨æ‰‹åŠ¿å›¾æ ‡ -->
            <div class="top-gestures">
                <div class="gesture-item">
                    <div class="gesture-icon">ğŸ‘†</div>
                    <div class="gesture-text">é£ŸæŒ‡æ§åˆ¶æ—‹è½¬</div>
                </div>
                <div class="gesture-item">
                    <div class="gesture-icon">ğŸ¤</div>
                    <div class="gesture-text">æåˆæ§åˆ¶å¤§å°</div>
                </div>
                <div class="gesture-item">
                    <div class="gesture-icon">ğŸ–ï¸</div>
                    <div class="gesture-text">æ‰‹è…•æ§åˆ¶èºåŠ¨</div>
                </div>
            </div>
        </header>
        
        <!-- ä¸»è¦ç”»å¸ƒåŒºåŸŸ -->
        <main class="main-content">
            <div class="canvas-container">
                <div class="canvas-header">
                    <span class="canvas-icon">ğŸ“¹</span>
                    <span class="canvas-title">æ‘„åƒå¤´ä¸æ‰‹åŠ¿æ£€æµ‹</span>
                </div>
                <canvas id="video-canvas" class="canvas"></canvas>
                <div class="canvas-footer" id="hand-status">ç­‰å¾…å¯åŠ¨...</div>
            </div>
            
            <div class="canvas-container">
                <div class="canvas-header">
                    <span class="canvas-icon">ğŸŒ </span>
                    <span class="canvas-title">3Dæ˜Ÿäº‘ç²’å­ç³»ç»Ÿ</span>
                </div>
                <canvas id="particle-canvas" class="canvas"></canvas>
                <div class="canvas-footer" id="particle-status">æ­£åœ¨åˆå§‹åŒ–...</div>
            </div>
        </main>
        
        <!-- æ§åˆ¶æŒ‰é’®åŒºåŸŸ -->
        <div class="controls">
            <button id="start-btn" class="btn btn-primary">å¯åŠ¨æ‘„åƒå¤´</button>
            <button id="stop-btn" class="btn btn-secondary">åœæ­¢æ‘„åƒå¤´</button>
            <button id="reset-btn" class="btn btn-secondary">é‡ç½®æ˜Ÿäº‘</button>
        </div>
        
        <!-- è¯¦ç»†è¯´æ˜åŒºåŸŸ -->
        <div class="detailed-instructions">
            <h2>æ‰‹åŠ¿æ§åˆ¶è¯¦ç»†è¯´æ˜</h2>
            <div class="instructions-grid">
                <div class="instruction-card">
                    <div class="instruction-icon">ğŸ‘†</div>
                    <h3>é£ŸæŒ‡ä½ç½®æ§åˆ¶æ˜Ÿäº‘æ—‹è½¬</h3>
                    <p>é£ŸæŒ‡æŒ‡å°–åœ¨æ‘„åƒå¤´ç”»é¢ä¸­çš„ä½ç½®æ§åˆ¶æ˜Ÿäº‘æ—‹è½¬æ–¹å‘ã€‚å‘å·¦ç§»åŠ¨é£ŸæŒ‡ï¼Œæ˜Ÿäº‘å‘å·¦æ—‹è½¬ï¼›å‘å³ç§»åŠ¨é£ŸæŒ‡ï¼Œæ˜Ÿäº‘å‘å³æ—‹è½¬ï¼›å‘ä¸Šç§»åŠ¨é£ŸæŒ‡ï¼Œæ˜Ÿäº‘å‘ä¸Šå€¾æ–œï¼›å‘ä¸‹ç§»åŠ¨é£ŸæŒ‡ï¼Œæ˜Ÿäº‘å‘ä¸‹å€¾æ–œã€‚</p>
                </div>
                
                <div class="instruction-card">
                    <div class="instruction-icon">ğŸ¤</div>
                    <h3>æ‰‹æŒ‡æåˆæ§åˆ¶æ˜Ÿäº‘å¤§å°</h3>
                    <p>é£ŸæŒ‡å’Œæ‹‡æŒ‡ä¹‹é—´çš„è·ç¦»æ§åˆ¶æ˜Ÿäº‘çš„ç¼©æ”¾æ¯”ä¾‹ã€‚æåˆæ‰‹æŒ‡ï¼ˆæ‰‹æŒ‡é è¿‘ï¼‰ï¼Œæ˜Ÿäº‘ç¼©å°ï¼›å±•å¼€æ‰‹æŒ‡ï¼ˆæ‰‹æŒ‡è¿œç¦»ï¼‰ï¼Œæ˜Ÿäº‘æ”¾å¤§ã€‚å¯ä»¥ç²¾ç»†æ§åˆ¶æ˜Ÿäº‘çš„å¤§å°å˜åŒ–ã€‚</p>
                </div>
                
                <div class="instruction-card">
                    <div class="instruction-icon">ğŸ–ï¸</div>
                    <h3>æ‰‹è…•ç§»åŠ¨æ§åˆ¶ç²’å­èºåŠ¨</h3>
                    <p>æ‰‹è…•çš„ç§»åŠ¨é€Ÿåº¦å’Œå¹…åº¦æ§åˆ¶æ˜Ÿäº‘ç²’å­çš„èºåŠ¨ç¨‹åº¦ã€‚å¿«é€Ÿç§»åŠ¨æ‰‹è…•ï¼Œç²’å­ä¼šå˜å¾—æ´»è·ƒã€èºåŠ¨ï¼›ç¼“æ…¢ç§»åŠ¨æˆ–ä¿æŒé™æ­¢ï¼Œç²’å­ä¼šæ¢å¤å¹³é™ã€‚å¯ä»¥ç”¨æ¥åˆ›å»ºåŠ¨æ€æ•ˆæœã€‚</p>
                </div>
            </div>
            
            <div class="hint">
                <p>ğŸ’¡ æç¤ºï¼šç¡®ä¿æ‰‹éƒ¨åœ¨æ‘„åƒå¤´ç”»é¢ä¸­æ¸…æ™°å¯è§ï¼Œå…‰çº¿å……è¶³æ•ˆæœæ›´ä½³ã€‚æ²¡æœ‰æ‰‹åŠ¿æ—¶ï¼Œæ˜Ÿäº‘ä¼šæœ‰è‡ªç„¶çš„å¾®å¼±è¿åŠ¨ã€‚</p>
            </div>
        </div>
        
        <footer class="footer">
            <p>ä½¿ç”¨ MediaPipe Hands å’Œ Three.js æ„å»º | æ‰‹åŠ¿æ§åˆ¶3Dæ˜Ÿäº‘ | ä¼˜åŒ–ç‰ˆ</p>
        </footer>
    </div>
    
    <!-- éšè—çš„videoå…ƒç´ ç”¨äºæ‘„åƒå¤´ -->
    <video id="video" class="hidden" autoplay muted playsinline></video>
    
    <!-- ä¸»è„šæœ¬ -->
    <script src="script.js"></script>
</body>
</html>
```
</details>

<details>
<summary>è¿™æ˜¯css</summary>
```css
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', sans-serif;
    background: linear-gradient(135deg, #0a0a1a 0%, #151530 100%);
    color: #e6e6ff;
    line-height: 1.6;
    min-height: 100vh;
    overflow-x: hidden;
}

.app-container {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    max-width: 100%;
    overflow-x: hidden;
}

/* å›ºå®šæ ‡é¢˜åŒºåŸŸ */
.header {
    text-align: center;
    padding: 20px;
    background: rgba(10, 15, 35, 0.95);
    border-bottom: 1px solid rgba(80, 120, 200, 0.3);
    backdrop-filter: blur(10px);
    position: sticky;
    top: 0;
    z-index: 100;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
}

h1 {
    font-size: 2.5rem;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
}

.emoji {
    font-size: 2.8rem;
    filter: drop-shadow(0 0 10px rgba(100, 150, 255, 0.6));
}

.title-text {
    color: #b0b0ff;
    text-shadow: 0 0 10px rgba(100, 150, 255, 0.5);
}

.subtitle {
    font-size: 1.1rem;
    color: #b0b0ff;
    margin-bottom: 15px;
}

/* é¡¶éƒ¨æ‰‹åŠ¿å›¾æ ‡ */
.top-gestures {
    display: flex;
    justify-content: center;
    gap: 40px;
    margin-top: 20px;
    flex-wrap: wrap;
}

.gesture-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.gesture-icon {
    font-size: 2.5rem;
    filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.7));
}

.gesture-text {
    color: #d0d0ff;
    font-size: 0.95rem;
    font-weight: 500;
}

/* ä¸»è¦å†…å®¹åŒºåŸŸ */
.main-content {
    display: flex;
    height: 60vh;
    padding: 20px;
    gap: 20px;
    flex: 1;
}

.canvas-container {
    flex: 1;
    background: rgba(10, 15, 35, 0.8);
    border-radius: 12px;
    border: 1px solid rgba(80, 120, 200, 0.3);
    box-shadow: 0 10px 30px rgba(0, 20, 80, 0.3);
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.canvas-header {
    padding: 15px 20px;
    background: rgba(20, 25, 50, 0.7);
    border-bottom: 1px solid rgba(100, 150, 255, 0.3);
    display: flex;
    align-items: center;
    gap: 12px;
}

.canvas-icon {
    font-size: 1.6rem;
    filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5));
}

.canvas-title {
    font-size: 1.2rem;
    color: #b0b0ff;
    font-weight: 600;
}

.canvas {
    width: 100%;
    height: 100%;
    background: #000;
    display: block;
}

.canvas-footer {
    padding: 12px 20px;
    background: rgba(20, 25, 50, 0.7);
    border-top: 1px solid rgba(100, 150, 255, 0.3);
    text-align: center;
    color: #b0b0ff;
    font-size: 0.9rem;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* æ§åˆ¶æŒ‰é’®åŒºåŸŸ */
.controls {
    display: flex;
    justify-content: center;
    gap: 15px;
    padding: 15px;
    margin-top: 10px;
}

.btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 120px;
}

.btn-primary {
    background: linear-gradient(135deg, #4169e1, #5d8eff);
    color: white;
}

.btn-primary:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(65, 105, 225, 0.4);
}

.btn-secondary {
    background: rgba(60, 65, 100, 0.8);
    color: #e0e0ff;
    border: 1px solid rgba(100, 150, 255, 0.4);
}

.btn-secondary:hover {
    background: rgba(80, 85, 120, 0.9);
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(100, 150, 255, 0.2);
}

/* è¯¦ç»†è¯´æ˜åŒºåŸŸ */
.detailed-instructions {
    padding: 30px 20px;
    background: rgba(10, 15, 35, 0.9);
    border-top: 1px solid rgba(80, 120, 200, 0.3);
    margin-top: 20px;
}

.detailed-instructions h2 {
    text-align: center;
    margin-bottom: 30px;
    color: #b0b0ff;
    font-size: 1.8rem;
}

.instructions-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 25px;
    margin-bottom: 25px;
}

.instruction-card {
    background: rgba(20, 25, 50, 0.7);
    border-radius: 12px;
    padding: 25px;
    border: 1px solid rgba(100, 150, 255, 0.3);
    transition: all 0.3s ease;
}

.instruction-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 15px 30px rgba(0, 20, 80, 0.3);
    border-color: #6496ff;
}

.instruction-icon {
    font-size: 3rem;
    margin-bottom: 15px;
    text-align: center;
    filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
}

.instruction-card h3 {
    color: #d0d0ff;
    font-size: 1.3rem;
    margin-bottom: 15px;
    text-align: center;
}

.instruction-card p {
    color: #b0b0ff;
    font-size: 0.95rem;
    line-height: 1.5;
}

.hint {
    background: rgba(20, 25, 50, 0.6);
    border-radius: 10px;
    padding: 15px 20px;
    border: 1px solid rgba(100, 150, 255, 0.3);
    text-align: center;
    max-width: 800px;
    margin: 0 auto;
}

.hint p {
    color: #d0d0ff;
    font-size: 0.95rem;
}

/* é¡µè„š */
.footer {
    text-align: center;
    padding: 20px;
    background: rgba(10, 15, 35, 0.9);
    border-top: 1px solid rgba(80, 120, 200, 0.3);
    color: #b0b0ff;
    font-size: 0.9rem;
}

/* éšè—å…ƒç´  */
.hidden {
    display: none;
}

/* å“åº”å¼è®¾è®¡ */
@media (max-width: 1100px) {
    .main-content {
        flex-direction: column;
        height: auto;
        min-height: 70vh;
    }
    
    .canvas-container {
        min-height: 350px;
    }
    
    .top-gestures {
        gap: 20px;
    }
    
    .instructions-grid {
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }
}

@media (max-width: 768px) {
    h1 {
        font-size: 2rem;
        flex-direction: column;
        gap: 10px;
    }
    
    .emoji {
        font-size: 2.2rem;
    }
    
    .subtitle {
        font-size: 0.95rem;
    }
    
    .top-gestures {
        gap: 15px;
    }
    
    .gesture-icon {
        font-size: 2rem;
    }
    
    .gesture-text {
        font-size: 0.85rem;
    }
    
    .main-content {
        padding: 15px;
    }
    
    .canvas-header {
        padding: 12px 15px;
    }
    
    .canvas-title {
        font-size: 1.1rem;
    }
    
    .controls {
        flex-wrap: wrap;
    }
    
    .btn {
        min-width: 100px;
        padding: 10px 20px;
        font-size: 0.9rem;
    }
    
    .detailed-instructions {
        padding: 20px 15px;
    }
    
    .detailed-instructions h2 {
        font-size: 1.5rem;
        margin-bottom: 20px;
    }
    
    .instruction-card {
        padding: 20px;
    }
    
    .instruction-icon {
        font-size: 2.5rem;
    }
    
    .instruction-card h3 {
        font-size: 1.2rem;
    }
    
    .instruction-card p {
        font-size: 0.9rem;
    }
}
```
</details>

<details>
<summary>è¿™æ˜¯javascript</summary>
```javascript
// å…¨å±€å˜é‡
let videoElement;
let videoCanvas;
let videoCtx;
let particleCanvas;
let handStatus;
let particleStatus;

// Three.jsç›¸å…³å˜é‡
let scene, camera, renderer, particles;
let particleGeometry, particleMaterial;
let particleCount = 12000; // å¢åŠ ç²’å­æ•°é‡
let basePositions = [];

// MediaPipeç›¸å…³å˜é‡
let hands;
let handResults = null;
let lastHandPosition = null;
let lastGestureTime = 0;
let isCameraActive = false;

// æ˜Ÿäº‘æ§åˆ¶å‚æ•°
let scale = 1.0;           // æ˜Ÿäº‘å¤§å°
let rotationX = 0;         // Xè½´æ—‹è½¬
let rotationY = 0;         // Yè½´æ—‹è½¬
let agitation = 0;         // èºåŠ¨å¼ºåº¦

// é¢œè‰²å¢å¼ºå‚æ•° - å¤§å¹…å¢å¼ºé¢œè‰²
let colorIntensity = 2.5;  // é¢œè‰²å¼ºåº¦å¢å¼º
let saturationBoost = 1.8; // é¥±å’Œåº¦å¢å¼º
let contrastBoost = 1.8;   // å¯¹æ¯”åº¦å¢å¼º

// åŠ¨ç”»å‚æ•°
let time = 0;
let animationFrameId = null;

// åˆå§‹åŒ–å‡½æ•°
function init() {
    console.log("å¼€å§‹åˆå§‹åŒ–æ‰‹åŠ¿æ§åˆ¶3Dæ˜Ÿäº‘ç³»ç»Ÿ...");
    
    // è·å–DOMå…ƒç´ 
    videoElement = document.getElementById('video');
    videoCanvas = document.getElementById('video-canvas');
    particleCanvas = document.getElementById('particle-canvas');
    
    if (!videoElement || !videoCanvas || !particleCanvas) {
        console.error("æ— æ³•æ‰¾åˆ°å¿…è¦çš„HTMLå…ƒç´ ");
        return;
    }
    
    videoCtx = videoCanvas.getContext('2d');
    handStatus = document.getElementById('hand-status');
    particleStatus = document.getElementById('particle-status');
    
    console.log("DOMå…ƒç´ è·å–æˆåŠŸ");
    
    // åˆå§‹åŒ–Three.jsåœºæ™¯
    initThreeJSScene();
    
    // åˆå§‹åŒ–MediaPipe Hands
    initMediaPipeHands();
    
    // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
    setupEventListeners();
    
    // å¯åŠ¨åŠ¨ç”»å¾ªç¯
    animate();
    
    console.log("ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
}

// åˆå§‹åŒ–Three.jsåœºæ™¯
function initThreeJSScene() {
    try {
        console.log("åˆå§‹åŒ–Three.jsåœºæ™¯...");
        
        // åˆ›å»ºåœºæ™¯
        scene = new THREE.Scene();
        
        // åˆ›å»ºé€è§†ç›¸æœº
        const aspect = particleCanvas.clientWidth / particleCanvas.clientHeight;
        camera = new THREE.PerspectiveCamera(70, aspect, 0.1, 3000);
        camera.position.z = 50;
        
        // åˆ›å»ºæ¸²æŸ“å™¨
        renderer = new THREE.WebGLRenderer({
            canvas: particleCanvas,
            antialias: true,
            alpha: true,
            powerPreference: 'high-performance'
        });
        renderer.setSize(particleCanvas.clientWidth, particleCanvas.clientHeight);
        renderer.setClearColor(0x000000, 1);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        createVibrantParticleSystem();
        
        console.log("Three.jsåœºæ™¯åˆå§‹åŒ–æˆåŠŸ");
        particleStatus.textContent = 'é²œè‰³3Dæ˜Ÿäº‘ç³»ç»Ÿå·²å°±ç»ª - ' + particleCount + 'ä¸ªç²’å­';
        
    } catch (error) {
        console.error("Three.jsåˆå§‹åŒ–å¤±è´¥:", error);
        particleStatus.textContent = 'æ˜Ÿäº‘ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥';
    }
}

// åˆ›å»ºé²œè‰³çš„ç²’å­ç³»ç»Ÿ
function createVibrantParticleSystem() {
    try {
        console.log("åˆ›å»ºé²œè‰³çš„ç²’å­ç³»ç»Ÿ...");
        
        // åˆ›å»ºç²’å­å‡ ä½•ä½“
        particleGeometry = new THREE.BufferGeometry();
        
        // é‡ç½®æ•°ç»„
        basePositions = [];
        
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        
        // åˆ›å»ºå¤šä¸ªé²œè‰³çš„æ˜Ÿäº‘æ ¸å¿ƒ
        const cores = [
            { x: 0, y: 0, z: 0, radius: 25, colorHue: 0.65, density: 0.35 }, // ä¸»æ ¸å¿ƒ - äº®è“è‰²
            { x: 15, y: 5, z: -10, radius: 15, colorHue: 0.8, density: 0.25 }, // å‰¯æ ¸å¿ƒ - ç´«è‰²
            { x: -10, y: -8, z: 8, radius: 12, colorHue: 0.9, density: 0.15 }, // å‰¯æ ¸å¿ƒ - ç²‰è‰²
            { x: 5, y: 12, z: 15, radius: 10, colorHue: 0.55, density: 0.15 }, // å‰¯æ ¸å¿ƒ - é’è‰²
            { x: -15, y: 10, z: -5, radius: 8, colorHue: 0.3, density: 0.1 } // å‰¯æ ¸å¿ƒ - æ©™è‰²
        ];
        
        let particleIndex = 0;
        
        // ä¸ºæ¯ä¸ªæ ¸å¿ƒåˆ›å»ºé²œè‰³çš„ç²’å­
        for (const core of cores) {
            const particlesInCore = Math.floor(particleCount * core.density);
            
            for (let i = 0; i < particlesInCore && particleIndex < particleCount; i++) {
                // åœ¨æ ¸å¿ƒå†…éšæœºåˆ†å¸ƒ
                const radius = core.radius * Math.pow(Math.random(), 0.5);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = core.x + radius * Math.sin(phi) * Math.cos(theta);
                const y = core.y + radius * Math.sin(phi) * Math.sin(theta);
                const z = core.z + radius * Math.cos(phi);
                
                // æ·»åŠ ä¸€äº›éšæœºæ‰°åŠ¨ï¼Œå½¢æˆæ˜Ÿäº‘å½¢çŠ¶
                const perturb = 3;
                const px = x + (Math.random() - 0.5) * perturb;
                const py = y + (Math.random() - 0.5) * perturb;
                const pz = z + (Math.random() - 0.5) * perturb;
                
                // ä¿å­˜ä½ç½®
                positions[particleIndex * 3] = px;
                positions[particleIndex * 3 + 1] = py;
                positions[particleIndex * 3 + 2] = pz;
                
                basePositions.push(px, py, pz);
                
                // è®¡ç®—åˆ°æ ¸å¿ƒçš„è·ç¦»ï¼Œç”¨äºé¢œè‰²å’Œå¤§å°
                const distance = Math.sqrt(x*x + y*y + z*z) / core.radius;
                
                // åˆ›å»ºé²œè‰³çš„é¢œè‰² - å¤§å¹…å¢å¼ºé¥±å’Œåº¦å’Œäº®åº¦
                let hue, saturation, lightness;
                
                // æ ¸å¿ƒåŒºåŸŸ - æ›´äº®æ›´é²œè‰³
                if (distance < 0.3) {
                    hue = core.colorHue + (Math.random() - 0.5) * 0.08;
                    saturation = 0.98 + Math.random() * 0.02; // æé«˜é¥±å’Œåº¦
                    lightness = 0.85 + Math.random() * 0.15; // é«˜äº®åº¦
                } else if (distance < 0.7) {
                    hue = core.colorHue + (Math.random() - 0.5) * 0.15;
                    saturation = 0.9 + Math.random() * 0.08; // é«˜é¥±å’Œåº¦
                    lightness = 0.75 + Math.random() * 0.15; // ä¸­ç­‰äº®åº¦
                } else {
                    hue = core.colorHue + (Math.random() - 0.5) * 0.25;
                    saturation = 0.8 + Math.random() * 0.15; // ä¸­ç­‰é¥±å’Œåº¦
                    lightness = 0.6 + Math.random() * 0.2; // è¾ƒä½äº®åº¦
                }
                
                const color = new THREE.Color();
                color.setHSL(hue, saturation, lightness);
                
                // å¢å¼ºé¢œè‰²å¼ºåº¦ - ä½¿é¢œè‰²æ›´é²œè‰³
                colors[particleIndex * 3] = Math.min(2.0, color.r * colorIntensity);
                colors[particleIndex * 3 + 1] = Math.min(2.0, color.g * colorIntensity);
                colors[particleIndex * 3 + 2] = Math.min(2.0, color.b * colorIntensity);
                
                // è®¾ç½®ç²’å­å¤§å° - æ ¸å¿ƒç²’å­æ›´å¤§æ›´äº®
                let size;
                if (distance < 0.2) {
                    size = 0.18 + Math.random() * 0.12; // æ ¸å¿ƒç²’å­æ›´å¤§
                } else if (distance < 0.5) {
                    size = 0.12 + Math.random() * 0.08;
                } else {
                    size = 0.08 + Math.random() * 0.06;
                }
                sizes[particleIndex] = size;
                
                particleIndex++;
            }
        }
        
        // æ·»åŠ èƒŒæ™¯åˆ†å¸ƒçš„é²œè‰³æ˜Ÿå°˜ç²’å­
        for (; particleIndex < particleCount; particleIndex++) {
            // åœ¨æ›´å¤§èŒƒå›´å†…éšæœºåˆ†å¸ƒ
            const range = 60;
            const px = (Math.random() - 0.5) * range;
            const py = (Math.random() - 0.5) * range * 0.7;
            const pz = (Math.random() - 0.5) * range;
            
            positions[particleIndex * 3] = px;
            positions[particleIndex * 3 + 1] = py;
            positions[particleIndex * 3 + 2] = pz;
            
            basePositions.push(px, py, pz);
            
            // èƒŒæ™¯ç²’å­é¢œè‰² - å„ç§é²œè‰³é¢œè‰²
            const hue = Math.random(); // å…¨è‰²è°±èŒƒå›´
            const saturation = 0.8 + Math.random() * 0.2; // é«˜é¥±å’Œåº¦
            const lightness = 0.7 + Math.random() * 0.3; // è¾ƒé«˜äº®åº¦
            
            const color = new THREE.Color();
            color.setHSL(hue, saturation, lightness);
            
            // å¢å¼ºèƒŒæ™¯ç²’å­é¢œè‰²
            colors[particleIndex * 3] = Math.min(2.0, color.r * 2.0);
            colors[particleIndex * 3 + 1] = Math.min(2.0, color.g * 2.0);
            colors[particleIndex * 3 + 2] = Math.min(2.0, color.b * 2.0);
            
            // èƒŒæ™¯ç²’å­å¤§å°
            const size = 0.06 + Math.random() * 0.06;
            sizes[particleIndex] = size;
        }
        
        // è®¾ç½®å‡ ä½•ä½“å±æ€§
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        // åˆ›å»ºè‡ªå®šä¹‰ç€è‰²å™¨æè´¨ï¼Œå®ç°é²œè‰³å‘å…‰æ•ˆæœ
        const vertexShader = `
            attribute float size;
            attribute vec3 color;
            varying vec3 vColor;
            varying float vSize;
            uniform float time;
            uniform float scale;
            uniform float agitation;
            uniform float saturationBoost;
            uniform float colorIntensity;
            
            // å™ªå£°å‡½æ•°ï¼Œç”¨äºè‡ªç„¶è¿åŠ¨å’ŒèºåŠ¨æ•ˆæœ
            float noise(vec3 p) {
                return sin(p.x*1.5 + time*0.5) * cos(p.y*1.3 + time*0.3) * sin(p.z*1.7 + time*0.7);
            }
            
            void main() {
                // å¢å¼ºé¢œè‰²é¥±å’Œåº¦å’Œå¼ºåº¦
                vec3 enhancedColor = color * colorIntensity * saturationBoost;
                vColor = enhancedColor;
                vSize = size;
                
                // åº”ç”¨åŸºç¡€ä½ç½®
                vec3 pos = position;
                
                // åº”ç”¨ç¼©æ”¾
                pos *= scale;
                
                // åº”ç”¨èºåŠ¨æ•ˆæœ
                float noiseValue = noise(pos * 0.05 + time);
                pos.x += noiseValue * agitation * 3.0;
                pos.y += noise(pos.yzx * 0.05 + time) * agitation * 3.0;
                pos.z += noise(pos.zxy * 0.05 + time) * agitation * 2.0;
                
                // æ·»åŠ å¾®å¼±çš„è‡ªç„¶è¿åŠ¨ï¼ˆæ¨¡æ‹Ÿæ˜Ÿäº‘æµåŠ¨ï¼‰
                float naturalMovement = sin(time * 0.2 + position.x * 0.02) * 0.5;
                pos.x += naturalMovement;
                pos.y += cos(time * 0.3 + position.y * 0.02) * 0.5;
                pos.z += sin(time * 0.25 + position.z * 0.02) * 0.3;
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                
                // ç²’å­å¤§å°éšèºåŠ¨å˜åŒ– - èºåŠ¨æ—¶ç²’å­æ›´å¤§æ›´äº®
                float sizeFactor = 1.0 + agitation * 1.5 + sin(time * 0.5 + position.x * 0.01) * 0.5;
                gl_PointSize = size * sizeFactor * (500.0 / -mvPosition.z);
                
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        
        const fragmentShader = `
            varying vec3 vColor;
            varying float vSize;
            
            void main() {
                // è®¡ç®—ç²’å­ä¸­å¿ƒçš„è·ç¦»
                vec2 coord = gl_PointCoord - vec2(0.5);
                float distance = length(coord);
                
                // åœ†å½¢ç²’å­
                if (distance > 0.5) {
                    discard;
                }
                
                // æ ¸å¿ƒåŒºåŸŸæ›´äº® - æ ¹æ®ç²’å­å¤§å°è°ƒæ•´
                float coreSize = 0.5 - vSize * 0.1;
                float core = smoothstep(0.5, coreSize, distance);
                
                // å‘å…‰å…‰æ™•æ•ˆæœ - æ›´å¼ºçƒˆçš„å‘å…‰
                float glow = pow(1.0 - distance * 2.0, 4.0) * 2.5;
                
                // è¾¹ç¼˜å‘å…‰æ•ˆæœ
                float edgeGlow = pow(1.0 - distance * 1.3, 3.0) * 2.0;
                
                // ç»„åˆæ•ˆæœ
                float alpha = core * 1.5 + glow * 1.0 + edgeGlow * 0.7;
                alpha = min(alpha, 2.0);
                
                // æœ€ç»ˆé¢œè‰²ï¼Œå¢å¼ºå‘å…‰æ•ˆæœ
                vec3 finalColor = vColor + vec3(glow * 1.0) + vec3(edgeGlow * 0.5);
                finalColor = min(finalColor, vec3(3.0)); // é™åˆ¶æœ€å¤§äº®åº¦
                
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;
        
        particleMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                scale: { value: scale },
                agitation: { value: agitation },
                saturationBoost: { value: saturationBoost },
                colorIntensity: { value: colorIntensity }
            },
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);
        
        console.log("é²œè‰³ç²’å­ç³»ç»Ÿåˆ›å»ºæˆåŠŸ");
        
    } catch (error) {
        console.error("åˆ›å»ºç²’å­ç³»ç»Ÿå¤±è´¥:", error);
        particleStatus.textContent = 'åˆ›å»ºç²’å­ç³»ç»Ÿå¤±è´¥';
    }
}

// åˆå§‹åŒ–MediaPipe Hands
function initMediaPipeHands() {
    try {
        console.log("åˆå§‹åŒ–MediaPipe Hands...");
        
        // æ£€æŸ¥MediaPipeæ˜¯å¦åŠ è½½
        if (typeof window.Hands === 'undefined') {
            console.error("MediaPipe HandsæœªåŠ è½½");
            handStatus.textContent = "MediaPipeåº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢";
            return;
        }
        
        hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });
        
        hands.onResults(onHandResults);
        
        console.log("MediaPipe Handsåˆå§‹åŒ–æˆåŠŸ");
        handStatus.textContent = "æ‰‹éƒ¨æ£€æµ‹ç³»ç»Ÿå°±ç»ª";
        
    } catch (error) {
        console.error("MediaPipeåˆå§‹åŒ–å¤±è´¥:", error);
        handStatus.textContent = "æ‰‹éƒ¨æ£€æµ‹ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥";
    }
}

// å¤„ç†æ‰‹éƒ¨æ£€æµ‹ç»“æœ - ä¿®å¤ï¼šç»˜åˆ¶åŸå§‹æ‘„åƒå¤´ç”»é¢
function onHandResults(results) {
    if (!results) {
        return;
    }
    
    handResults = results;
    
    // ç»˜åˆ¶æ‘„åƒå¤´ç”»é¢ - ä¿®å¤ï¼šç¡®ä¿ç»˜åˆ¶åŸå§‹å½©è‰²ç”»é¢
    if (results.image && videoCtx) {
        videoCtx.save();
        videoCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
        // ç»˜åˆ¶åŸå§‹æ‘„åƒå¤´ç”»é¢ï¼ˆå½©è‰²ï¼‰
        videoCtx.drawImage(results.image, 0, 0, videoCanvas.width, videoCanvas.height);
        videoCtx.restore();
    }
    
    // å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°æ‰‹éƒ¨
    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
        handStatus.textContent = 'æœªæ£€æµ‹åˆ°æ‰‹éƒ¨ï¼Œè¯·å°†æ‰‹æ”¾åœ¨æ‘„åƒå¤´å‰';
        
        // ç¼“æ…¢é‡ç½®å‚æ•°ï¼Œä½†ä¿æŒè½»å¾®è¿åŠ¨
        scale = scale * 0.98 + 1.0 * 0.02;
        rotationX *= 0.95;
        rotationY *= 0.95;
        agitation *= 0.95;
        
        return;
    }
    
    // æ£€æµ‹åˆ°æ‰‹éƒ¨
    handStatus.textContent = 'æ‰‹éƒ¨å·²æ£€æµ‹åˆ°ï¼Œæ­£åœ¨åˆ†ææ‰‹åŠ¿...';
    
    // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹ï¼ˆåœ¨å½©è‰²ç”»é¢ä¸Šå åŠ ç»˜åˆ¶ï¼‰
    if (results.multiHandLandmarks && videoCtx) {
        for (const landmarks of results.multiHandLandmarks) {
            drawHand(landmarks);
            processHandGesture(landmarks);
        }
    }
}

// ç»˜åˆ¶æ‰‹éƒ¨
function drawHand(landmarks) {
    if (!videoCtx) return;
    
    videoCtx.save();
    
    // ç»˜åˆ¶è¿æ¥çº¿
    videoCtx.strokeStyle = '#00FF00';
    videoCtx.lineWidth = 2;
    
    // ç»˜åˆ¶æ‰‹éƒ¨è¿æ¥çº¿
    const connections = [
        [0, 1], [1, 2], [2, 3], [3, 4], // æ‹‡æŒ‡
        [0, 5], [5, 6], [6, 7], [7, 8], // é£ŸæŒ‡
        [0, 9], [9, 10], [10, 11], [11, 12], // ä¸­æŒ‡
        [0, 13], [13, 14], [14, 15], [15, 16], // æ— åæŒ‡
        [0, 17], [17, 18], [18, 19], [19, 20], // å°æŒ‡
        [5, 9], [9, 13], [13, 17] // æ‰‹æŒ
    ];
    
    for (const [start, end] of connections) {
        const startPoint = landmarks[start];
        const endPoint = landmarks[end];
        
        videoCtx.beginPath();
        videoCtx.moveTo(startPoint.x * videoCanvas.width, startPoint.y * videoCanvas.height);
        videoCtx.lineTo(endPoint.x * videoCanvas.width, endPoint.y * videoCanvas.height);
        videoCtx.stroke();
    }
    
    // ç»˜åˆ¶å…³é”®ç‚¹ï¼ˆç‰¹åˆ«æ ‡è®°é£ŸæŒ‡å’Œæ‹‡æŒ‡æŒ‡å°–ï¼‰
    for (let i = 0; i < landmarks.length; i++) {
        const landmark = landmarks[i];
        let color = '#FFFF00'; // é»˜è®¤é»„è‰²
        
        if (i === 0) {
            color = '#ff1493'; // æ‰‹è…•ç²‰è‰²
        } else if ([4, 8, 12, 16, 20].includes(i)) {
            color = '#00ffff'; // æŒ‡å°–é’è‰²
        }
        
        // ç‰¹åˆ«æ ‡è®°é£ŸæŒ‡æŒ‡å°–(8)å’Œæ‹‡æŒ‡æŒ‡å°–(4)
        if (i === 8) {
            color = '#ff00ff'; // é£ŸæŒ‡æŒ‡å°–å“çº¢è‰²
        } else if (i === 4) {
            color = '#ffff00'; // æ‹‡æŒ‡æŒ‡å°–äº®é»„è‰²
        }
        
        videoCtx.fillStyle = color;
        videoCtx.beginPath();
        videoCtx.arc(
            landmark.x * videoCanvas.width,
            landmark.y * videoCanvas.height,
            (i === 0) ? 6 : (i === 8 || i === 4) ? 8 : 4,
            0,
            Math.PI * 2
        );
        videoCtx.fill();
        
        // ä¸ºé£ŸæŒ‡å’Œæ‹‡æŒ‡æŒ‡å°–æ·»åŠ å‘å…‰æ•ˆæœ
        if (i === 8 || i === 4) {
            videoCtx.shadowColor = color;
            videoCtx.shadowBlur = 15;
            videoCtx.fill();
            videoCtx.shadowBlur = 0;
        }
    }
    
    videoCtx.restore();
}

// å¤„ç†æ‰‹åŠ¿æ•°æ® - æ ¸å¿ƒæ§åˆ¶æ˜ å°„
function processHandGesture(landmarks) {
    if (!landmarks || landmarks.length < 21) return;
    
    const now = Date.now();
    const wrist = landmarks[0];              // æ‰‹è…•
    const thumbTip = landmarks[4];           // æ‹‡æŒ‡æŒ‡å°–
    const indexTip = landmarks[8];           // é£ŸæŒ‡æŒ‡å°–
    
    // æ§åˆ¶æ˜ å°„1: é£ŸæŒ‡æŒ‡å°–åæ ‡æ˜ å°„ä¸ºæ˜Ÿäº‘æ—‹è½¬è§’åº¦
    // å°†å½’ä¸€åŒ–çš„å±å¹•åæ ‡æ˜ å°„åˆ°æ—‹è½¬è§’åº¦
    rotationY = (indexTip.x - 0.5) * 4;      // -2 åˆ° 2 çš„èŒƒå›´
    rotationX = (0.5 - indexTip.y) * 2;      // -1 åˆ° 1 çš„èŒƒå›´
    
    // æ§åˆ¶æ˜ å°„2: é£ŸæŒ‡ä¸æ‹‡æŒ‡æŒ‡å°–è·ç¦»æ˜ å°„ä¸ºæ˜Ÿäº‘ç¼©æ”¾
    // è®¡ç®—é£ŸæŒ‡å’Œæ‹‡æŒ‡æŒ‡å°–ä¹‹é—´çš„è·ç¦»
    const thumbIndexDistance = Math.sqrt(
        Math.pow(thumbTip.x - indexTip.x, 2) + 
        Math.pow(thumbTip.y - indexTip.y, 2)
    );
    
    // å½’ä¸€åŒ–è·ç¦»å¹¶æ˜ å°„åˆ°ç¼©æ”¾èŒƒå›´ 0.5 åˆ° 3.0
    scale = 0.5 + thumbIndexDistance * 2.5;
    scale = Math.max(0.5, Math.min(3.0, scale));
    
    // æ§åˆ¶æ˜ å°„3: æ‰‹è…•ç§»åŠ¨é€Ÿåº¦æ˜ å°„ä¸ºç²’å­èºåŠ¨å¼ºåº¦
    if (lastHandPosition) {
        const deltaTime = (now - lastGestureTime) / 1000;
        if (deltaTime > 0) {
            const deltaX = wrist.x - lastHandPosition.x;
            const deltaY = wrist.y - lastHandPosition.y;
            const movementSpeed = Math.sqrt(deltaX * deltaX + deltaY * deltaY) / deltaTime;
            
            // å°†é€Ÿåº¦æ˜ å°„åˆ°èºåŠ¨å¼ºåº¦ 0 åˆ° 2
            agitation = Math.min(2.0, movementSpeed * 5);
        }
        lastGestureTime = now;
    }
    
    lastHandPosition = { x: wrist.x, y: wrist.y };
}

// è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
function setupEventListeners() {
    console.log("è®¾ç½®äº‹ä»¶ç›‘å¬å™¨...");
    
    // çª—å£å¤§å°æ”¹å˜æ—¶æ›´æ–°ç”»å¸ƒå°ºå¯¸
    window.addEventListener('resize', onWindowResize);
    
    // æŒ‰é’®äº‹ä»¶ç›‘å¬
    document.getElementById('start-btn').addEventListener('click', startCamera);
    document.getElementById('stop-btn').addEventListener('click', stopCamera);
    document.getElementById('reset-btn').addEventListener('click', resetParticles);
    
    // åˆå§‹åŒ–çª—å£å¤§å°
    onWindowResize();
    
    console.log("äº‹ä»¶ç›‘å¬å™¨è®¾ç½®å®Œæˆ");
}

// çª—å£å¤§å°æ”¹å˜å¤„ç†
function onWindowResize() {
    if (particleCanvas && renderer && camera) {
        const width = particleCanvas.parentElement.clientWidth;
        const height = particleCanvas.parentElement.clientHeight;
        
        particleCanvas.width = width;
        particleCanvas.height = height;
        
        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
    }
    
    if (videoCanvas) {
        const width = videoCanvas.parentElement.clientWidth;
        const height = videoCanvas.parentElement.clientHeight;
        
        videoCanvas.width = width;
        videoCanvas.height = height;
    }
}

// å¯åŠ¨æ‘„åƒå¤´
async function startCamera() {
    try {
        console.log("æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´...");
        handStatus.textContent = 'æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™...';
        
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®");
        }
        
        const stream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: 'user',
                frameRate: { ideal: 30 }
            },
            audio: false
        });
        
        console.log("æ‘„åƒå¤´æƒé™å·²è·å¾—");
        
        videoElement.srcObject = stream;
        handStatus.textContent = 'æ‘„åƒå¤´å·²å¯åŠ¨ï¼Œè¯·å°†æ‰‹æ”¾åœ¨æ‘„åƒå¤´å‰';
        
        await new Promise((resolve) => {
            videoElement.onloadedmetadata = () => {
                videoElement.play().then(resolve).catch(() => resolve());
            };
        });
        
        isCameraActive = true;
        processVideoFrame();
        
        console.log("æ‘„åƒå¤´å¯åŠ¨æˆåŠŸ");
        
    } catch (error) {
        console.error('æ‘„åƒå¤´è®¿é—®é”™è¯¯:', error);
        handStatus.textContent = 'æ— æ³•è®¿é—®æ‘„åƒå¤´';
        
        let errorMessage = 'æ— æ³•è®¿é—®æ‘„åƒå¤´ã€‚è¯·ç¡®ä¿å·²æˆäºˆæ‘„åƒå¤´æƒé™ã€‚';
        if (error.name === 'NotAllowedError') {
            errorMessage = 'æ‘„åƒå¤´è®¿é—®è¢«æ‹’ç»ã€‚è¯·å…è®¸æ‘„åƒå¤´æƒé™å¹¶åˆ·æ–°é¡µé¢ã€‚';
        } else if (error.name === 'NotFoundError') {
            errorMessage = 'æœªæ‰¾åˆ°æ‘„åƒå¤´è®¾å¤‡ã€‚è¯·æ£€æŸ¥æ‘„åƒå¤´è¿æ¥ã€‚';
        } else if (error.name === 'NotReadableError') {
            errorMessage = 'æ‘„åƒå¤´æ­£è¢«å…¶ä»–åº”ç”¨å ç”¨ã€‚';
        }
        
        alert(errorMessage);
    }
}

// å¤„ç†è§†é¢‘å¸§
async function processVideoFrame() {
    if (!isCameraActive) return;
    
    try {
        if (videoElement.readyState < 2) {
            setTimeout(() => processVideoFrame(), 100);
            return;
        }
        
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = videoElement.videoWidth || 640;
        tempCanvas.height = videoElement.videoHeight || 480;
        const tempCtx = tempCanvas.getContext('2d');
        
        // ç¡®ä¿ç»˜åˆ¶å½©è‰²å›¾åƒ
        tempCtx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);
        
        if (hands && typeof hands.send === 'function') {
            await hands.send({image: tempCanvas});
        }
        
        setTimeout(() => processVideoFrame(), 50);
    } catch (error) {
        console.error('å¤„ç†è§†é¢‘å¸§æ—¶å‡ºé”™:', error);
        setTimeout(() => processVideoFrame(), 100);
    }
}

// åœæ­¢æ‘„åƒå¤´
function stopCamera() {
    console.log("åœæ­¢æ‘„åƒå¤´");
    isCameraActive = false;
    
    if (videoElement.srcObject) {
        const tracks = videoElement.srcObject.getTracks();
        tracks.forEach(track => track.stop());
        videoElement.srcObject = null;
    }
    
    handStatus.textContent = 'æ‘„åƒå¤´å·²åœæ­¢';
    
    if (videoCtx) {
        videoCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
        // æ˜¾ç¤ºæç¤ºæ–‡å­—
        videoCtx.fillStyle = '#ffffff';
        videoCtx.font = '20px Arial';
        videoCtx.textAlign = 'center';
        videoCtx.fillText('æ‘„åƒå¤´å·²åœæ­¢', videoCanvas.width/2, videoCanvas.height/2);
    }
    
    handResults = null;
    
    // é‡ç½®å‚æ•°
    scale = 1.0;
    rotationX = 0;
    rotationY = 0;
    agitation = 0;
}

// é‡ç½®ç²’å­ç³»ç»Ÿ
function resetParticles() {
    console.log("é‡ç½®ç²’å­ç³»ç»Ÿ");
    
    // é‡æ–°åˆ›å»ºç²’å­ç³»ç»Ÿ
    if (scene && particles) {
        scene.remove(particles);
        createVibrantParticleSystem();
    }
    
    // é‡ç½®æ§åˆ¶å‚æ•°
    scale = 1.0;
    rotationX = 0;
    rotationY = 0;
    agitation = 0;
    time = 0;
    
    particleStatus.textContent = 'æ˜Ÿäº‘å·²é‡ç½®ä¸ºé²œè‰³çŠ¶æ€';
}

// åŠ¨ç”»å¾ªç¯
function animate(timestamp) {
    requestAnimationFrame(animate);
    
    // æ›´æ–°æ—¶é—´
    time = timestamp * 0.001;
    
    // æ›´æ–°æè´¨uniforms
    if (particleMaterial && particleMaterial.uniforms) {
        particleMaterial.uniforms.time.value = time;
        particleMaterial.uniforms.scale.value = scale;
        particleMaterial.uniforms.agitation.value = agitation;
        particleMaterial.uniforms.saturationBoost.value = saturationBoost;
        particleMaterial.uniforms.colorIntensity.value = colorIntensity;
    }
    
    // åº”ç”¨æ—‹è½¬
    if (particles) {
        particles.rotation.y += rotationY * 0.01;
        particles.rotation.x += rotationX * 0.01;
        
        // å³ä½¿æ²¡æœ‰æ‰‹åŠ¿ï¼Œä¹Ÿæ·»åŠ å¾®å¼±çš„è‡ªç„¶æ—‹è½¬
        if (Math.abs(rotationY) < 0.1 && Math.abs(rotationX) < 0.1) {
            particles.rotation.y += 0.01;
            particles.rotation.x += 0.005 * Math.sin(time * 0.1);
        }
        
        // æ·»åŠ è½»å¾®çš„è„‰åŠ¨æ•ˆæœï¼Œä½¿æ˜Ÿäº‘æ›´æœ‰ç”Ÿæ°”
        particles.rotation.z += 0.002 * Math.sin(time * 0.3);
    }
    
    // æ¸²æŸ“Three.jsåœºæ™¯
    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
window.addEventListener('DOMContentLoaded', () => {
    console.log("DOMåŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–");
    init();
});
```
</details>

***  

2025.12.17
## never_gonna_give_you_upä¼ªè£…æˆdeepseek
æˆ‘åœ¨çœ‹CS50çš„æ—¶å€™ï¼Œè€å¸ˆè®²åˆ°äº†ä¸€ä¸ªäº‹æƒ…ï¼š
htmlä¸­å†™ç½‘å€ï¼Œå¦‚æœå®é™…æ˜¯ç½‘å€Aï¼Œè€Œæœ¬è¯¥æ˜¯æ–‡å­—æè¿°çš„åœ°æ–¹å†™æˆç½‘å€Bï¼Œé‚£ä¹ˆå°±ä¼šå”¬ä½ä¸ä»”ç»†çš„äººï¼Œå°±æœ‰å¯èƒ½å®ç°é’“é±¼ã€‚
æ¯”å¦‚ä¸è¿™ä¹ˆå†™
```html
        <a href="https://www.bilibili.com/">è¿™æ˜¯å“”å“©å“”å“©</a >
    ```
è€Œæ˜¯å†™æˆ
```html
        <a href="https://www.bilibili.com/">www.example.com</a >
    ```
é‚£å°±æœ‰ä¸€å®šçš„ä¼ªè£…æ€§äº†

è¯¶ï¼Œæˆ‘ä¹Ÿè¦åš
äºæ˜¯ï¼Œæˆ‘å°±æ–°å»ºäº†ä¸ªhtmlæ–‡ä»¶ï¼Œå†™äº†è¿™äº›å†…å®¹
<details>
<summary>è¿™æ˜¯æˆ‘å†™çš„æµ‹è¯•.html</summary>
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
		a
		{
			text-decoration: none;
		}
		a:hover
		{
			text-decoration:underline;
		}
    </style>
    <title>æˆ‘åšçš„toy</title>
</head>
<body>
	<h2>
		<p style="text-align:center">
			ç‚¹å‡»è¿›å…¥deepseekå®˜ç½‘
		</p>
    </h2>
   
    <h3>
		<p style="text-align:center">
			<a href="https://www.bilibili.com/video/BV1GJ411x7h7/">https://chat.deepseek.com/</a>
		</p>
    </h3>
</body>
</html>
```
</details>


æ‰“å¼€ä¾¿æ˜¯è¿™ä¸ªæ•ˆæœ
<a href="æˆ‘çš„html.jpg" data-fancybox="gallery" data-caption="æµ‹è¯•.html">
  <img src="æˆ‘çš„html.jpg" width="50%" alt="æµ‹è¯•.html">
</a>
è€Œå¦‚æœæˆ‘ç‚¹å‡»é‚£ä¸ªæ‰€è°“çš„deepseeké“¾æ¥

å°±ä¼šçœ‹è§...
<a href="never_gonna_give_you_up.jpg" data-fancybox="gallery" data-caption="ä½ ä¼šçœ‹è§...">
  <img src="never_gonna_give_you_up.jpg" width="50%" alt="ä½ ä¼šçœ‹è§...">
</a>
å“ˆå“ˆï¼Œè¿˜è›®æœ‰æ„æ€çš„

***  

2025.12.27
## ç²’å­å°æ¸¸æˆ
é‚£å¤©æˆ‘åœ¨ç¾¤é‡Œå’ŒåŒå­¦é—²èŠ

åŒå­¦è·Ÿdeepseekè¦äº†ä¸€æ®µå¾ˆé…·çš„ä»£ç ï¼Œè®©æˆ‘è¿è¡Œç€ç©
<details>
<summary>pythonä»£ç åœ¨è¿™é‡Œ</summary>

```python
import pygame
import random
import math
import sys

# åˆå§‹åŒ–Pygame
pygame.init()

# å±å¹•è®¾ç½®
WIDTH, HEIGHT = 1200, 800
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("ç‚«é…·ç²’å­ç³»ç»Ÿæ¨¡æ‹Ÿ")

# é¢œè‰²å®šä¹‰
BLACK = (0, 0, 0)
COLORS = [
    (255, 50, 50),    # çº¢è‰²
    (50, 255, 50),    # ç»¿è‰²
    (50, 50, 255),    # è“è‰²
    (255, 255, 50),   # é»„è‰²
    (255, 50, 255),   # ç´«è‰²
    (50, 255, 255),   # é’è‰²
    (255, 150, 50),   # æ©™è‰²
    (200, 50, 255),   # ç²‰ç´«
]

# ç²’å­ç±»
class Particle:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.size = random.randint(2, 6)
        self.color = random.choice(COLORS)
        self.speed_x = random.uniform(-2, 2)
        self.speed_y = random.uniform(-2, 2)
        self.life = random.randint(100, 255)
        self.gravity = 0.05
        self.trail = []
        self.max_trail_length = 10
        
    def update(self):
        # ä¿å­˜è½¨è¿¹ç‚¹
        self.trail.append((self.x, self.y))
        if len(self.trail) > self.max_trail_length:
            self.trail.pop(0)
        
        # æ›´æ–°ä½ç½®
        self.x += self.speed_x
        self.y += self.speed_y
        
        # åº”ç”¨é‡åŠ›
        self.speed_y += self.gravity
        
        # éšæœºè¿åŠ¨å˜åŒ–
        self.speed_x += random.uniform(-0.1, 0.1)
        self.speed_y += random.uniform(-0.1, 0.1)
        
        # é™åˆ¶é€Ÿåº¦
        speed = math.sqrt(self.speed_x**2 + self.speed_y**2)
        if speed > 5:
            self.speed_x = (self.speed_x / speed) * 5
            self.speed_y = (self.speed_y / speed) * 5
        
        # è¾¹ç•Œåå¼¹
        if self.x <= 0 or self.x >= WIDTH:
            self.speed_x *= -0.8
            self.x = max(0, min(WIDTH, self.x))
        if self.y <= 0 or self.y >= HEIGHT:
            self.speed_y *= -0.8
            self.y = max(0, min(HEIGHT, self.y))
        
        # ç”Ÿå‘½è¡°å‡
        self.life -= 1
        
        # ç²’å­é€æ¸å˜å°
        self.size = max(0.5, self.size * 0.99)
        
    def draw(self, surface):
        # ç»˜åˆ¶è½¨è¿¹
        for i, (trail_x, trail_y) in enumerate(self.trail):
            alpha = int(self.life * (i / len(self.trail)))
            size = self.size * (i / len(self.trail))
            if size > 0:
                trail_color = (
                    min(255, self.color[0] + 50),
                    min(255, self.color[1] + 50),
                    min(255, self.color[2] + 50),
                    alpha
                )
                pygame.draw.circle(
                    surface, 
                    trail_color, 
                    (int(trail_x), int(trail_y)), 
                    max(0.5, size)
                )
        
        # ç»˜åˆ¶ç²’å­
        pygame.draw.circle(
            surface, 
            self.color, 
            (int(self.x), int(self.y)), 
            max(0.5, self.size)
        )
        
        # ç»˜åˆ¶å…‰æ™•æ•ˆæœ
        glow_surface = pygame.Surface((int(self.size * 6), int(self.size * 6)), pygame.SRCALPHA)
        pygame.draw.circle(
            glow_surface, 
            (*self.color, 30), 
            (int(self.size * 3), int(self.size * 3)), 
            self.size * 3
        )
        surface.blit(glow_surface, (int(self.x - self.size * 3), int(self.y - self.size * 3)), special_flags=pygame.BLEND_ALPHA_SDL2)

# ç²’å­ç³»ç»Ÿç®¡ç†å™¨
class ParticleSystem:
    def __init__(self):
        self.particles = []
        self.gradient_bg = self.create_gradient()
        
    def create_gradient(self):
        """åˆ›å»ºæ¸å˜è‰²èƒŒæ™¯"""
        gradient = pygame.Surface((WIDTH, HEIGHT))
        for y in range(HEIGHT):
            # ä»æ·±è“è‰²åˆ°é»‘è‰²çš„æ¸å˜
            color_value = int(10 + (y / HEIGHT) * 20)
            pygame.draw.line(gradient, (color_value//3, color_value//6, color_value), (0, y), (WIDTH, y))
        return gradient
        
    def add_particle(self, x, y):
        self.particles.append(Particle(x, y))
        
    def add_explosion(self, x, y, count=30):
        for _ in range(count):
            self.particles.append(Particle(x, y))
            
    def update(self):
        # æ›´æ–°æ‰€æœ‰ç²’å­
        for particle in self.particles[:]:
            particle.update()
            if particle.life <= 0 or particle.size <= 0.2:
                self.particles.remove(particle)
                
    def draw(self, surface):
        # ç»˜åˆ¶æ¸å˜èƒŒæ™¯
        surface.blit(self.gradient_bg, (0, 0))
        
        # ç»˜åˆ¶æ‰€æœ‰ç²’å­
        for particle in self.particles:
            particle.draw(surface)
            
        # ç»˜åˆ¶ç»Ÿè®¡ä¿¡æ¯
        font = pygame.font.SysFont(None, 24)
        stats_text = f"ç²’å­æ•°é‡: {len(self.particles)}"
        text_surface = font.render(stats_text, True, (200, 200, 200))
        surface.blit(text_surface, (10, 10))
        
        # ç»˜åˆ¶è¯´æ˜æ–‡å­—
        instructions = [
            "é¼ æ ‡ç‚¹å‡»: ç”Ÿæˆç²’å­",
            "é¼ æ ‡æ‹–æ‹½: ç”Ÿæˆç²’å­æµ",
            "ç©ºæ ¼é”®: ç”Ÿæˆçˆ†ç‚¸æ•ˆæœ",
            "Ré”®: é‡ç½®ç²’å­ç³»ç»Ÿ",
            "ESCé”®: é€€å‡º"
        ]
        
        for i, instruction in enumerate(instructions):
            text = font.render(instruction, True, (200, 200, 200))
            surface.blit(text, (WIDTH - 250, 20 + i * 25))

# ä¸»å‡½æ•°
def main():
    clock = pygame.time.Clock()
    particle_system = ParticleSystem()
    running = True
    mouse_down = False
    
    # åˆå§‹çˆ†ç‚¸æ•ˆæœ
    for _ in range(5):
        particle_system.add_explosion(
            random.randint(100, WIDTH-100),
            random.randint(100, HEIGHT-100),
            random.randint(20, 40)
        )
    
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
                
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    running = False
                elif event.key == pygame.K_SPACE:
                    # åœ¨éšæœºä½ç½®ç”Ÿæˆçˆ†ç‚¸
                    for _ in range(3):
                        particle_system.add_explosion(
                            random.randint(100, WIDTH-100),
                            random.randint(100, HEIGHT-100),
                            random.randint(20, 40)
                        )
                elif event.key == pygame.K_r:
                    # é‡ç½®ç²’å­ç³»ç»Ÿ
                    particle_system.particles.clear()
                    
            elif event.type == pygame.MOUSEBUTTONDOWN:
                mouse_down = True
                if event.button == 1:  # å·¦é”®
                    particle_system.add_explosion(event.pos[0], event.pos[1], 30)
                elif event.button == 3:  # å³é”®
                    # å³é”®åˆ›å»ºæŒç»­ç²’å­æµ
                    for _ in range(50):
                        particle_system.add_particle(event.pos[0], event.pos[1])
                        
            elif event.type == pygame.MOUSEBUTTONUP:
                mouse_down = False
                
            elif event.type == pygame.MOUSEMOTION and mouse_down:
                # é¼ æ ‡æ‹–æ‹½æ—¶ç”Ÿæˆç²’å­
                particle_system.add_particle(event.pos[0], event.pos[1])
        
        # éšæœºç”Ÿæˆä¸€äº›ç²’å­
        if random.random() < 0.1 and len(particle_system.particles) < 500:
            particle_system.add_particle(
                random.randint(0, WIDTH),
                random.randint(0, 50)
            )
        
        # æ›´æ–°ç²’å­ç³»ç»Ÿ
        particle_system.update()
        
        # ç»˜åˆ¶æ‰€æœ‰å†…å®¹
        particle_system.draw(screen)
        
        # æ›´æ–°æ˜¾ç¤º
        pygame.display.flip()
        clock.tick(60)
    
    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()
```
</details>

æˆ‘æ‰“å¼€Visual Studioï¼Œç‚¹å‡»è¿è¡Œï¼ŒæŠ¥é”™äº†ã€‚æ²¡æœ‰pygame

æˆ‘å°è¯•pip pygameï¼Œå‘ç°æˆ‘çš„Python3.14å¤ªæ–°äº†ï¼Œéš¾ä»¥å…¼å®¹

äºæ˜¯æˆ‘åˆé—®deepseekï¼Œè¿™ä¸ªä»£ç ï¼Œè¿˜æœ‰æ²¡æœ‰åˆ«çš„å®ç°æ–¹å¼

äºæ˜¯ä¾¿æ”¹æˆäº†HTML
<details>
<summary>ç‚¹å‡»æŸ¥çœ‹HTMLä»£ç </summary>

```html
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç‚«é…·ç²’å­ç³»ç»Ÿ (Webç‰ˆ)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            color: #ccc;
        }
        #canvasContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #particleCanvas {
            display: block;
            background: radial-gradient(ellipse at center, #0a0a2a 0%, #000000 100%);
        }
        #uiPanel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 40, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(100, 100, 255, 0.3);
            max-width: 300px;
            backdrop-filter: blur(5px);
        }
        h2, h3 {
            color: #6cf;
            margin-bottom: 10px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .value-display {
            text-align: right;
            font-size: 0.8em;
            color: #8af;
        }
        #stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="canvasContainer">
        <canvas id="particleCanvas"></canvas>
        <div id="uiPanel">
            <h2>âš¡ ç²’å­ç³»ç»Ÿæ§åˆ¶å°</h2>
            <div class="control-group">
                <h3>ç²’å­è¡Œä¸º</h3>
                <label for="gravitySlider">é‡åŠ›å¼ºåº¦: <span id="gravityValue">0.05</span></label>
                <input type="range" id="gravitySlider" min="0" max="0.2" step="0.01" value="0.05">
                
                <label for="speedSlider">åˆå§‹é€Ÿåº¦: <span id="speedValue">2.0</span></label>
                <input type="range" id="speedSlider" min="0.5" max="5" step="0.1" value="2.0">
                
                <label for="trailSlider">è½¨è¿¹é•¿åº¦: <span id="trailValue">10</span></label>
                <input type="range" id="trailSlider" min="1" max="20" step="1" value="10">
            </div>
            <div class="control-group">
                <h3>äº¤äº’ç”Ÿæˆ</h3>
                <button onclick="createExplosion(canvas.width/2, canvas.height/2, 50)">ä¸­å¿ƒçˆ†ç‚¸</button>
                <button onclick="particles = []">æ¸…é™¤æ‰€æœ‰ç²’å­</button>
                <p style="margin-top:10px; font-size:0.8em;">
                    æ“ä½œæç¤ºï¼š<br>
                    â€¢ é¼ æ ‡ç‚¹å‡»ï¼šç”Ÿæˆçˆ†ç‚¸<br>
                    â€¢ é¼ æ ‡æ‹–æ‹½ï¼šç”Ÿæˆç²’å­æµ<br>
                    â€¢ è‡ªåŠ¨è¾¹ç¼˜ç”Ÿæˆï¼šå·²å¼€å¯
                </p>
            </div>
        </div>
        <div id="stats">
            ç²’å­æ•°é‡: <span id="particleCount">0</span> | 
            å¸§ç‡: <span id="fps">0</span> FPS
        </div>
    </div>

    <script>
        // è·å–Canvasä¸Šä¸‹æ–‡
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ç²’å­é¢œè‰²æ± 
        const PARTICLE_COLORS = [
            '#ff3232', '#32ff32', '#3232ff', '#ffff32',
            '#ff32ff', '#32ffff', '#ff9632', '#c832ff'
        ];

        // æ ¸å¿ƒç²’å­ç±»
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 4 + 2;
                this.color = PARTICLE_COLORS[Math.floor(Math.random() * PARTICLE_COLORS.length)];
                this.speedX = (Math.random() - 0.5) * parseFloat(document.getElementById('speedSlider').value);
                this.speedY = (Math.random() - 0.5) * parseFloat(document.getElementById('speedSlider').value);
                this.life = 1.0; // å®Œå…¨ç”Ÿå‘½å€¼
                this.decay = Math.random() * 0.01 + 0.005; // è¡°å‡é€Ÿåº¦
                this.trail = [];
                this.maxTrailLength = parseInt(document.getElementById('trailSlider').value);
                this.gravity = parseFloat(document.getElementById('gravitySlider').value);
            }

            update() {
                // ä¿å­˜è½¨è¿¹
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > this.maxTrailLength) this.trail.shift();

                // åº”ç”¨ç‰©ç†
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.speedX += (Math.random() - 0.5) * 0.1;
                this.speedY += (Math.random() - 0.5) * 0.1;

                // è¾¹ç•Œç¢°æ’ï¼ˆå¸¦èƒ½é‡æŸå¤±ï¼‰
                if (this.x <= 0 || this.x >= canvas.width) {
                    this.speedX *= -0.8;
                    this.x = this.x <= 0 ? 1 : canvas.width - 1;
                }
                if (this.y <= 0 || this.y >= canvas.height) {
                    this.speedY *= -0.8;
                    this.y = this.y <= 0 ? 1 : canvas.height - 1;
                }

                // ç”Ÿå‘½è¡°å‡
                this.life -= this.decay;
                this.size *= 0.99;
                return this.life > 0 && this.size > 0.2;
            }

            draw() {
                // ç»˜åˆ¶è½¨è¿¹
                for (let i = 0; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    const alpha = this.life * (i / this.trail.length);
                    const size = this.size * (i / this.trail.length);
                    
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, Math.max(0.5, size), 0, Math.PI * 2);
                    ctx.fillStyle = this.hexToRgba(this.color, alpha);
                    ctx.fill();
                }

                // ç»˜åˆ¶ä¸»ç²’å­
                ctx.beginPath();
                ctx.arc(this.x, this.y, Math.max(0.5, this.size), 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();

                // å…‰æ™•æ•ˆæœ
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 3, 0, Math.PI * 2);
                ctx.fillStyle = this.hexToRgba(this.color, 0.15);
                ctx.fill();
            }

            hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
        }

        // ç²’å­ç³»ç»Ÿ
        let particles = [];
        let mouseX = 0, mouseY = 0, isMouseDown = false;
        let frameCount = 0, lastTime = performance.now(), fps = 0;

        // ç”Ÿæˆçˆ†ç‚¸
        function createExplosion(x, y, count) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y));
            }
        }

        // åˆå§‹åŒ–éšæœºçˆ†ç‚¸
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                createExplosion(
                    Math.random() * canvas.width * 0.6 + canvas.width * 0.2,
                    Math.random() * canvas.height * 0.6 + canvas.height * 0.2,
                    Math.floor(Math.random() * 30) + 20
                );
            }, i * 200);
        }

        // äº‹ä»¶ç›‘å¬
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            createExplosion(e.clientX, e.clientY, 30);
        });
        canvas.addEventListener('mouseup', () => isMouseDown = false);
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            if (isMouseDown) particles.push(new Particle(mouseX, mouseY));
        });
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // æ»‘å—äº‹ä»¶ç»‘å®š
        document.getElementById('gravitySlider').addEventListener('input', function() {
            document.getElementById('gravityValue').textContent = this.value;
        });
        document.getElementById('speedSlider').addEventListener('input', function() {
            document.getElementById('speedValue').textContent = this.value;
        });
        document.getElementById('trailSlider').addEventListener('input', function() {
            document.getElementById('trailValue').textContent = this.value;
        });

        // ä¸»åŠ¨ç”»å¾ªç¯
        function animate(currentTime) {
            // è®¡ç®—FPS
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;
            }

            // æ¸…å±ï¼ˆä½¿ç”¨åŠé€æ˜é»‘è‰²åˆ¶é€ æ‹–å°¾æ•ˆæœï¼‰
            ctx.fillStyle = 'rgba(10, 10, 30, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // éšæœºç”Ÿæˆæ–°ç²’å­ï¼ˆå¦‚æœæ•°é‡ä¸å¤šï¼‰
            if (Math.random() < 0.1 && particles.length < 500) {
                particles.push(new Particle(
                    Math.random() * canvas.width,
                    Math.random() * -50
                ));
            }

            // æ›´æ–°å¹¶ç»˜åˆ¶æ‰€æœ‰ç²’å­
            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i].update()) {
                    particles.splice(i, 1);
                } else {
                    particles[i].draw();
                }
            }

            // æ›´æ–°UIæ˜¾ç¤º
            document.getElementById('particleCount').textContent = particles.length;
            document.getElementById('fps').textContent = fps;

            requestAnimationFrame(animate);
        }

        // å¯åŠ¨åŠ¨ç”»
        animate(performance.now());
    </script>
</body>
</html>
```
</details>

æ•ˆæœæ˜¯è¿™æ ·çš„
<a href="ç²’å­å°æ¸¸æˆ.jpg" data-fancybox="gallery" data-caption="æ•ˆæœåœ¨è¿™é‡Œ">
  <img src="ç²’å­å°æ¸¸æˆ.jpg" width="50%" alt="æ•ˆæœåœ¨è¿™é‡Œ">
</a>

å…ˆå‰æˆ‘æ²¡ç»†çœ‹ä»£ç ï¼ˆå…¶å®ç»†çœ‹ä¹Ÿçœ‹ä¸å¤ªæ‡‚
æ‰€ä»¥ç‚¹å¼€ä¹‹åï¼Œæˆ‘è¿˜æŒºéœ‡æƒŠçš„
å°ä¸œè¥¿æŒºæœ‰æ„æ€å•ŠğŸ‘